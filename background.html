
    const EXPOSE_PATH = "Index";
    const ONEDRIVE_REFRESHTOKEN = "0.AUkAAykc8qIpEEG5DZlxD9NkuzXc1HhGfsZCkCMtOTFEM6VJAHo.AgABAAAAAAD--DLA3VO7QrddgJg7WevrAgDs_wQA9P8HO3xh3LoUZPPUxYLB78iTGVXFoxeFxInp39cppCHXCV7F48Id0YGhidZnYCDc6_jMVcHxGWXAy0KhQLUAArr99t8S6qFI-jCMUGeZzWI3xNTpsAPv5BLcnqzr2jqQ0sU8wAX612RIM5EXLt8o5Up8K_8uBvgz1WZ6-1mK43d_3e6lMWl8_LHtH8ls-loEkRXC90VDIeh8JH0gHjOpbyzthXWPJxTiMVyTAqMx7zuxCq_JH2XlTtNSc59aC3OQuT-p_knblymLQG2z0FDX_h5folfM2TYIqVHz4uO36aeWVOUYvepQdrtmORVQDs9px2260zSVAswqgkEr_E7byZueXrfDACZ_slu20L4M54xbOW-L2bcijZn4gTE9IkCxTohnz8VkyceczGHZtS7N11nzaEpBlnXRjbeNMNlHDZ4bb1Hefo5LgefcpZmiOyf3IQjCmqpvBeWI2WqWhOJniYqHeU_17vv54qbdQZaKKX6CtfAnrpncZJ8MbEoeuTVlVWAuDAaOeNsCfhNgGh1IN-ef1cBHVtC1NDxXP6phhlU0VKXs7oCKrCAtjGjYxFIGC--1bcQyIgdRWZgAUnpPDrBfUewnan1oLs6V-pYpdiVfsuP9_P77Rw38iuZZomdIEdtGHl4TT2_e3hUgE-ANV5yU0Q82TlQUJbTROcMN9MId9NBMsXMEUeVNoe9ij85tX0vGemhAlc2evYSqYC9NrjKjDT9GiRpdu96lg0pSWRu9BVEEBUqlasTwUoAf_FpQxaJLoLWcYUYXzjNn60bqiHxVQIBhivhQCAUuqHm60N_EzzK6mFvHISMO1R19DMlebvCLWRbRmw-JyqpH8lIPBGYLqUK9nNyEM1hLPAzYvSSNZGjAxZzYdexK0CQu-6qeMKpFDwN2HzheXmpMHkam8MMTCCAPTm_GA8OjF2wcCauQFVqI_GlnC_R6ku9kEdvFihUssvKVL2hYyYsSDPC2BUCXhY0wuGiWZoFHaR6I";
    const PASSWD_FILENAME = ".password";
    const clientId = "78d4dc35-7e46-42c6-9023-2d39314433a5";
    const clientSecret = "ZudGl-p.m=LMmr3VrKgAyOf-WevB3p50";
    const loginHost = "https://login.microsoftonline.com";
    const apiHost = "https://graph.microsoft.com";
    const redirectUri = "http://localhost/onedrive-login";

    async function handleRequest(request) {
      let querySplited, requestPath;
      let queryString = decodeURIComponent(request.url.split("?")[1]);
      if (queryString) querySplited = queryString.split("=");
      if (querySplited && querySplited[0] === "file") {
        const file = querySplited[1];
        const fileName = file.split("/").pop();
        if (fileName === PASSWD_FILENAME)
          return Response.redirect(
            "https://www.baidu.com/s?wd=%E6%80%8E%E6%A0%B7%E7%9B%97%E5%8F%96%E5%AF%86%E7%A0%81",
            301
          );
        requestPath = file.replace("/" + fileName, "");
        const url = await fetchFiles(requestPath, fileName);
        return Response.redirect(url, 302);
      } else {
        const { headers } = request;
        const contentType = headers.get("content-type");
        let body = {};
        if (contentType && contentType.includes("form")) {
          const formData = await request.formData();
          for (let entry of formData.entries()) {
            body[entry[0]] = entry[1];
          }
        }
        requestPath = Object.getOwnPropertyNames(body).length ? body["?path"] : "";
        const files = await fetchFiles(requestPath, null, body.passwd);
        return new Response(files, {
          headers: {
            "content-type": "application/json; charset=utf-8",
            "Access-Control-Allow-Origin": "*",
          },
        });
      }
    }

    addEventListener("fetch", (event) => {
      return event.respondWith(handleRequest(event.request));
    });

    const OAUTH = {
      redirectUri: redirectUri,
      refreshToken: ONEDRIVE_REFRESHTOKEN,
      clientId: clientId,
      clientSecret: clientSecret,
      oauthUrl: loginHost + "/common/oauth2/v2.0/",
      apiUrl: apiHost + "/v1.0/me/drive/root",
      scope: apiHost + "/Files.ReadWrite.All offline_access",
    };

    async function gatherResponse(response) {
      const { headers } = response;
      const contentType = headers.get("content-type");
      if (contentType.includes("application/json")) {
        return await response.json();
      } else if (contentType.includes("application/text")) {
        return await response.text();
      } else if (contentType.includes("text/html")) {
        return await response.text();
      } else {
        return await response.text();
      }
    }

    async function getContent(url) {
      const response = await fetch(url);
      const result = await gatherResponse(response);
      return result;
    }

    async function getContentWithHeaders(url, headers) {
      const response = await fetch(url, { headers: headers });
      const result = await gatherResponse(response);
      return result;
    }

    async function fetchFormData(url, data) {
      const formdata = new FormData();
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          formdata.append(key, data[key]);
        }
      }
      const requestOptions = {
        method: "POST",
        body: formdata,
      };
      const response = await fetch(url, requestOptions);
      const result = await gatherResponse(response);
      return result;
    }

    async function fetchAccessToken() {
      url = OAUTH["oauthUrl"] + "token";
      data = {
        client_id: OAUTH["clientId"],
        client_secret: OAUTH["clientSecret"],
        grant_type: "refresh_token",
        requested_token_use: "on_behalf_of",
        refresh_token: OAUTH["refreshToken"],
      };
      const result = await fetchFormData(url, data);
      return result.access_token;
    }

    async function fetchFiles(path, fileName, passwd) {
      if (path === "/") path = "";
      if (path || EXPOSE_PATH) path = ":" + EXPOSE_PATH + path;

      const accessToken = await fetchAccessToken();
      const uri =
        OAUTH.apiUrl +
        encodeURI(path) +
        "?expand=children(select=name,size,parentReference,lastModifiedDateTime,@microsoft.graph.downloadUrl)";
      const body = await getContentWithHeaders(uri, {
        Authorization: "Bearer " + accessToken,
      });
      if (fileName) {
        let thisFile = null;
        body.children.forEach((file) => {
          if (file.name === decodeURIComponent(fileName)) {
            thisFile = file["@microsoft.graph.downloadUrl"];
            return;
          }
        });
        return thisFile;
      } else {
        let files = [];
        let encrypted = false;
        for (let i = 0; i < body.children.length; i++) {
          const file = body.children[i];
          if (file.name === PASSWD_FILENAME) {
            const PASSWD = await getContent(file["@microsoft.graph.downloadUrl"]);
            if (PASSWD !== passwd) {
              encrypted = true;
              break;
            } else {
              continue;
            }
          }
          files.push({
            name: file.name,
            size: file.size,
            time: file.lastModifiedDateTime,
            url: file["@microsoft.graph.downloadUrl"],
          });
        }
        let parent = body.children.length
          ? body.children[0].parentReference.path
          : body.parentReference.path;
        parent = parent.split(":").pop().replace(EXPOSE_PATH, "") || "/";
        parent = decodeURIComponent(parent);
        if (encrypted) {
          return JSON.stringify({ parent: parent, files: [], encrypted: true });
        } else {
          return JSON.stringify({ parent: parent, files: files });
        }
      }
    }
  
